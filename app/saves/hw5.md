​	

根据题意，我们需要给出一个生成矩阵H使得任意一个初始状态向量都可以通过H编码为唯一的三维向量。

* 初始状况（-1 代表 轻于标准；1代表 重于标准；向量第i位代表第i枚硬币）

  * `[0,..,1,...,0]`
  * `[0,...,-1,...,0]`
  * `[0,...,0]`

* 方法生成思路

  * 我们可以先固定第一次的称重方案我们（H的第一行）为`[1,1,1,1,-1,-1,-1,-1,0,0,0,0]`，其中1标记了左盘的称重对象，-1标记了右盘的称重对象。因此编码后的第一位就代表着左右盘的大小情况（计算得 1 代表 左盘更重）
  * 为了缩小编程寻找的范围，我们将每次称重比较限制在**4枚硬币和4枚硬币**的比较上来。显而易见的是，如果没有假币存在那么，编码的结果应该为`[0,0,0]`
  * 假设第i枚硬币是假币，且重于标准值。那么我们根据假币的唯一性可以得到编码的结果应该为`[H[0][i-1],H[1][i-1],H[2][i-1]]`。与之对应的，如果轻于标准值，编码结果应该为`[-H[0][i-1],-H[1][i-1],-H[2][i-1]]`
  * 根据上面的分析，我们只要满足生成矩阵列向量间互不相等，列向量间和不为零向量，以及列向量本身不为零向量即可的到一个可行的方案
  * 由于我们只需要找到一个可行方案，所以采用了随机查找的方式

* 代码实现

  ```python
  import numpy as np
  
  a = [1] * 4 + [-1] * 4 + [0] * 4
  a = np.array(a)
  b = a.copy()
  c = a.copy()
  np.random.shuffle(b)
  np.random.shuffle(c)
  flag = True
  
  while(1):
      for i in range(0,12):
          for j in range(0,i):
              if((a[i] == a[j] and b[i] == b[j] and c[i] == c[j]) or (a[i] + a[j] == 0 and b[i] + b[j] == 0 and c[i] + c[j] == 0) or (a[i] == 0 and b[i] == 0 and c[i] == 0)):
                  flag = False
                  break
          if(not flag):
              break
      if(flag):   
          break
      else:
          np.random.shuffle(b)
          np.random.shuffle(c)
          flag = True
  
  print(b)
  print(c)    
  
  
  ```

* 一个可行结果

  ![1555318859507](hw5.assets/1555318859507.png)

  
